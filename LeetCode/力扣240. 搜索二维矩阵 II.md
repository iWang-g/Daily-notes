# 力扣240. 搜索二维矩阵 II 题解


## 一、题目分析
**题目链接**：[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)  
**核心特性**：矩阵中**每行从左到右递增**，**每列从上到下递增**（但行首不一定大于上行行尾，如示例中第3行首元素3 < 第2行尾元素19）。  
**目标**：设计高效算法判断目标值是否存在于矩阵中。


## 二、初始思路的问题诊断
你的思路尝试通过行首/列首的大小关系定位目标可能所在的行/列，但存在以下问题：
1. **逻辑漏洞**：  
   - 若目标大于某行首且小于下一行首（如目标5 > 第1行首2，且 < 第2行首3），仅搜索上一行（第1行）是正确的，但代码中`else res = search_x(m - 1, target, matrix);`会错误覆盖结果（例如当目标在中间行时，被强制搜索最后一行）。  
   - 同时遍历行首和列首属于重复操作，且未考虑矩阵非“严格递增矩阵”（行首可能小于上行行尾）的特性，导致漏判或误判。
2. **效率问题**：  
   `search_x`和`search_y`是遍历整行/整列（O(n)或O(m)），最坏情况下复杂度为O(mn)，未利用矩阵的有序性优化。


## 三、优化思路：从“右上角/左下角”开始搜索
### 核心灵感：
矩阵的右上角元素具有特殊性：  
- **小于它的元素一定在其左侧**（因为行递增）。  
- **大于它的元素一定在其下方**（因为列递增）。  
类似地，左下角元素也有此特性（小于它的在上方，大于它的在右侧）。  
**通过这种“单调性”，可每次排除一行或一列，快速缩小搜索范围**。

### 步骤示例（以右上角为起点）：
以示例1矩阵（目标5）为例：  
1. 起点：右上角`(0,4)=15`，5 < 15 → 排除该列（列数-1，移动到`(0,3)=11`）。  
2. 5 < 11 → 排除该列（列数-1，移动到`(0,2)=7`）。  
3. 5 < 7 → 排除该列（列数-1，移动到`(0,1)=4`）。  
4. 5 > 4 → 排除该行（行数+1，移动到`(1,1)=5`），找到目标！  


## 四、C++代码实现（优化后）
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty() || matrix[0].empty()) return false; // 空矩阵处理
        
        int m = matrix.size();    // 行数
        int n = matrix[0].size(); // 列数
        int i = 0, j = n - 1;     // 起点：右上角（i=0行，j=最后一列）
        
        while (i < m && j >= 0) { // 行不越界，列不越界
            if (matrix[i][j] == target) {
                return true;      // 找到目标
            } else if (matrix[i][j] > target) {
                j--;              // 目标更小，排除当前列（左移一列）
            } else {
                i++;              // 目标更大，排除当前行（下移一行）
            }
        }
        return false; // 越界后仍未找到
    }
};
```


## 五、代码解析
### 1. 边界处理：
```cpp
if (matrix.empty() || matrix[0].empty()) return false;
```
- 防止矩阵为空（行数0或列数0）导致的访问越界。

### 2. 搜索起点与范围：
```cpp
int i = 0, j = n - 1; // 起点：右上角（也可选择左下角i=m-1,j=0）
```
- **右上角优势**：初始时可排除的行列最多，无需遍历所有行首/列首。

### 3. 核心逻辑：
```cpp
while (i < m && j >= 0) {
    if (matrix[i][j] == target) return true;
    else if (matrix[i][j] > target) j--; // 目标在左侧，排除当前列
    else i++; // 目标在下方，排除当前行
}
```
- **每次迭代排除一行或一列**：时间复杂度O(m + n)（最多移动m行+n列），空间复杂度O(1)（仅用常数变量）。


## 六、对比初始思路的改进点
| 初始思路 | 优化思路 |
|----------|----------|
| 遍历行首/列首定位行/列，可能重复搜索 | 从右上角出发，利用单调性一次排除一行/列 |
| 最坏情况O(mn)（遍历整行/整列） | 最坏情况O(m + n)（行数+列数） |
| 逻辑复杂（需处理单行/单列、边界判断） | 逻辑简洁（仅需越界判断和大小比较） |


## 七、总结
本题的关键是利用矩阵**行递增且列递增**的特性，从右上角（或左下角）作为搜索起点，通过比较目标值与当前元素的大小，每次排除一行或一列，将时间复杂度从O(mn)优化到O(m + n)，是高效且简洁的经典解法。