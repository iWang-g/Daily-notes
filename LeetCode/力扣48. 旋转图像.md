# 力扣48. 旋转图像笔记


## 一、题目描述
**题目链接**：[48. 旋转图像](https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&envId=top-100-liked)  
**题目要求**：给定一个 `n×n` 的二维矩阵 `matrix`，表示一个图像。请你将图像**顺时针旋转90度**，且必须**原地**旋转（直接修改输入矩阵，不使用额外矩阵）。


### 示例说明
- **示例1**：  
  输入：`matrix = [[1,2,3],[4,5,6],[7,8,9]]`  
  输出：`[[7,4,1],[8,5,2],[9,6,3]]`  
  （注：顺时针旋转90度后，原矩阵的第一列变为新矩阵的第一行，顺序反转）

- **示例2**：  
  输入：`matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]`  
  输出：`[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]`  


## 二、解题思路
### 1. 初始思路
最初观察到：**旋转90度时，每个元素会与另外3个元素构成一个“循环”**（比如示例1中的四个角元素 `1→3→9→7→1`）。通过依次交换这4个元素的位置，可以完成旋转。但不清楚如何**系统地找出所有循环**，以及**避免重复处理**。


### 2. 优化后的思路（分层循环交换）
为了解决初始思路的问题，我们采用**分层处理+循环交换**的方法：
- **矩阵分层**：`n×n` 矩阵有 `k = n//2` 层（最外层为第0层，向内逐层递增）。例如，3×3矩阵有1层（仅最外层），4×4矩阵有2层（外层和内层）。  
- **每层处理**：对第 `layer` 层，横向处理从 `layer` 到 `n-1-layer-1` 的列（避免重复处理循环的最后一个元素）。  
- **循环交换**：每层中的每个元素 `(i,j)` 会与另外3个元素构成旋转循环（左上角→左下角→右下角→右上角→左上角），通过**临时变量暂存**和**依次覆盖**的顺序交换这4个元素，完成旋转。


### 关键原理：旋转坐标转换
原位置 `(i,j)` 顺时针旋转90度后的新位置为 `(j, n-1-i)`（行变为原列，列变为原行的对称行）。基于此，我们可以推导出循环中的4个位置：
- 左上角：`(layer, i)`（当前层的左边界，横向第i个元素）  
- 左下角：`(n-1-layer, layer)` → 修正为 `(n-1 - (i - layer), layer)`（行坐标为“当前层下边界 - 横向偏移量”）  
- 右下角：`(n-1-layer, n-1-layer)` → 修正为 `(n-1-layer, n-1 - (i - layer))`（列坐标为“当前层右边界 - 横向偏移量”）  
- 右上角：`(i, n-1-layer)`（当前层的右边界，横向第i个元素）  


## 三、C++代码实现
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        // 遍历每一层（从外层到内层，共n//2层）
        for (int layer = 0; layer < n / 2; ++layer) {
            int start = layer;               // 当前层的左/上边界
            int end = n - 1 - layer;         // 当前层的右/下边界（闭区间）
            // 遍历当前层需要旋转的元素（横向范围：start到end-1，避免重复）
            for (int i = start; i < end; ++i) {
                // 暂存左上角元素 (start, i)
                int temp = matrix[start][i];
                
                // 步骤1：左下角元素覆盖左上角（原左下角→左上角）
                matrix[start][i] = matrix[end - (i - start)][start];
                
                // 步骤2：右下角元素覆盖左下角（原右下角→左下角）
                matrix[end - (i - start)][start] = matrix[end][end - (i - start)];
                
                // 步骤3：右上角元素覆盖右下角（原右上角→右下角）
                matrix[end][end - (i - start)] = matrix[i][end];
                
                // 步骤4：暂存的左上角元素覆盖右上角（原左上角→右上角）
                matrix[i][end] = temp;
            }
        }
    }
};
```


## 四、代码解析
### 1. 分层处理
```cpp
for (int layer = 0; layer < n / 2; ++layer) { ... }
```
- `layer` 表示当前处理的层（从0开始，到 `n//2 - 1` 结束）。例如，4×4矩阵处理2层（外层 `layer=0`，内层 `layer=1`）。
- 内层矩阵的中心元素（如3×3的中心5）无需旋转，因此只需处理 `n//2` 层。


### 2. 每层元素范围
```cpp
int start = layer;               // 当前层的左边界（列）/上边界（行）
int end = n - 1 - layer;         // 当前层的右边界（列）/下边界（行）
for (int i = start; i < end; ++i) { ... }
```
- `start` 和 `end` 定义了当前层的边界（例如，外层 `layer=0` 时，`start=0`，`end=3`（4×4矩阵））。
- `i` 遍历从 `start` 到 `end-1` 的列（横向），避免处理循环的最后一个元素（否则会重复旋转）。


### 3. 循环交换步骤
以**示例1（3×3矩阵，外层 `layer=0`，`i=0`）**为例：
- **暂存左上角**：`temp = matrix[0][0] = 1`（保存原左上角元素）。
- **左下角覆盖左上角**：`matrix[0][0] = matrix[2 - (0-0)][0] = matrix[2][0] = 7`（原左下角元素7移到左上角）。
- **右下角覆盖左下角**：`matrix[2][0] = matrix[2][2 - (0-0)] = matrix[2][2] = 9`（原右下角元素9移到左下角）。
- **右上角覆盖右下角**：`matrix[2][2] = matrix[0][2] = 3`（原右上角元素3移到右下角）。
- **暂存值覆盖右上角**：`matrix[0][2] = temp = 1`（原左上角元素1移到右上角）。

**结果**：左上角循环 `(0,0)→(2,0)→(2,2)→(0,2)` 完成旋转，元素变为 `7,9,3,1`，与目标矩阵一致。


### 4. 关键细节
- **坐标计算**：`end - (i - start)` 表示“当前层下边界 - 横向偏移量”，用于准确找到左下角和右下角的位置。
- **临时变量**：必须用 `temp` 暂存第一个元素，否则会覆盖未使用的元素（例如，直接赋值 `a→b→c→d` 会导致 `a` 的值丢失）。
- **原地旋转**：所有操作均直接修改输入矩阵，未使用额外矩阵，空间复杂度为 `O(1)`。


## 五、复杂度分析
- **时间复杂度**：`O(n²)`（每个元素恰好被处理一次）。
- **空间复杂度**：`O(1)`（仅使用常数级别的临时变量）。


## 总结
本题的核心思路是**分层处理+循环交换**，通过找出旋转后的元素循环，依次交换循环中的4个元素，实现原地旋转。这种方法高效且符合题目要求，是解决“原地旋转矩阵”问题的经典方法。